---
{
    .title = "Exploring Gleam through Advent of Code",
    .description = "I've explored the young programming language Gleam by doing Advent of Code 2016 using it. This post outlines my thoughts about Gleam so far, but is quite limited to the AoC single-problem perspective.",
    .author = "Adam CL",
    .layout = "post.shtml",
    .date = @date("2024-11-11T11:31:00"),
    .draft = false,
    .tags = ["gleam", "advent of code", "beam"],
}
---

## [Quick Intro to Gleam]($section.id("intro"))
[Gleam](https://gleam.run) is a statically typed functional programming language that gets compiled to either [BEAM](https://en.wikipedia.org/wiki/BEAM_(Erlang_virtual_machine)) or JavaScript. Its syntax is more akin to [Rust](https://rust-lang.org) than other BEAM languages such as [Elixir](https://elixir-lang.org) and [Erlang](https://erlang.org).

```gleam
// gleam

pub fn split(x: String, on substring: String) -> List(String) {
  case substring {
    "" -> to_graphemes(x)
    _ ->
      x
      |> string_builder.from_string
      |> string_builder.split(on: substring)
      |> list.map(with: string_builder.to_string)
  }
}
```

## [Why I Chose Gleam]($section.id("why"))
First and foremost, I wanted to try something new. Gleam ticked quite a few of the boxes of things I like in a language:

- Static type system
- Immutability
- Compiled
- Built-in tooling
- Decent standard library

For the purpose of AoC, it's mainly the type system, tooling and standard library I'm choosing Gleam. I might take on doing something more complicated (and distributed) afterwards.

## [First Impressions]($section.id("first-impressions"))

As I usually work in procedural languages, getting into the strictly functional paradigm has been the biggest hurdle. Don't get me wrong - I often use the functional style functions of JS, but due to its mutability and dynamic typing, it's far from Gleam. I've previously delved into Elixir, and while it is also functional it's got the dynamic typing to make it less of a jump. After completing the first 8 days of AoC, I'm getting used to it and I see the light that is immutability. In the codebase I spend most time in at work, there's plenty of functionality that modifies in-place, causing both confusion and bugs for developers who are new to the code.

### [Missed Functionality #1]($section.id("first-miss"))

When it comes to AoC, it's very common to work with arrays/lists, for instance in a matrix:

```python
# python

matrix = [['a', 'b'], ['c', 'd']]
matrix[0][0] # 'a'
```

Let's say then that a task requires shifting rows by 1:

```python
# python

def shift_row_right(matrix, row_index, n):
    row = matrix[row_index]
    n = n % len(row)
    shifted_row = row[-n:] + row[:-n]
    matrix[row_index] = shifted_row
    return matrix

shift_row_right(matrix, 0, 1) # [['b', 'a'], ['c', 'd']]
```

Performance aside, this is a very simple and neat way of accessing elements in a list. In Gleam, you can't access lists by index. Instead, you have to iterate through the list until you're on the right index. Pairing this with the immutability means that shifting rows as above is a bit more tedious. For AoC 2016 day 8, this was the solution I came up with for shifting rows with wrap around:

```gleam
// gleam

pub fn shift_row_right(
  matrix: Matrix(value),
  row: Int,
  shift: Int,
) -> Matrix(value) {
  Matrix(
    cells: list.index_map(matrix.cells, fn(current_row, row_index) {
      case row_index == row {
        True -> {
          let values =
            list.index_map(current_row, fn(value, col_index) {
              let source_pos = case col_index + shift % matrix.width {
                n if n >= matrix.width -> n - matrix.width
                n -> n
              }
              #(col_index, source_pos, value)
            })

          list.index_map(current_row, fn(value, col_index) {
            case
              list.find(values, fn(triple) {
                let #(_, source, _) = triple
                source == col_index
              })
            {
              Ok(#(_, _, v)) -> v
              Error(_) -> value
            }
          })
        }
        False -> current_row
      }
    }),
    width: matrix.width,
    height: matrix.height,
  )
}
```

As you can see, it's certainly more verbose. I'm certain that this is not the most performant solution (using `list.find` repeatedly makes this not ideal for big matrices), but that's not the point - had it been possible to just access the values through indices, we'd not need the verbose iterating. As long as the underlying data structured is a single linked list (as it is in Gleam), the performance would still be linear, but the verbosity would be less if there was a `list.at` function.
