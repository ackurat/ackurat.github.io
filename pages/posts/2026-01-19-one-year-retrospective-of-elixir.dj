%{
  title: "One Year Retrospective of Elixir",
  description: "I've worked with Elixir professionally for one year now, and this post is gathers some reflections on the language and its tooling",
  keywords: ["elixir", "programming"],
  draft: true,
}

---

I spend about 90% of my professional development in Elixir (the remaining time is a mix of Erlang and Go), and I couldn't be happier. That said, not everything is perfect. My previous experiences with Elixir are limited to a university course in functional programming, which mainly consisted of solving math-like problems, and Advent of Code, which again is focused on solving math-like problems. In other words, I was pretty much a beginner when I joined my current team.

I generally think that tooling and ecosystem is more important than the language itself, so I'll primarily focus on that in this post.

## Tooling

### Mix as a Build Tool

`Mix` works great - it's extensible, can compile on multiple cores (since v19.4), handles everything from compilation to installation of dependencies and package managers. One thing I really like is that the mixfile of a project, `mix.exs`, is just regular Elixir. This means that I can script the build step freely using the language I already now, and I don't have to shell out into various scripts like I used to do in the `Node` ecosystem. Want to add a CLI task to simplify running tests in CI? Just write an alias function and add it to the `project` in the mixfile:

```elixir
def aliases() do
    ci: ["deps.unlock --check-unused", "format --check-formatted", "cmd docker compose up --detach --wait", "test"]
end
```

Now just run `mix ci` and it'll run whatever you defined in the alias. This extensibility is not limited to just running code in your mixfile, as you can extend mix with your own [tasks](https://hexdocs.pm/mix/Mix.Task.html). One simple example is the [generator](https://github.com/ackurat/ackurat.github.io/blob/main/lib/mix/tasks/post.ex) I use to create new posts.

### Test Runner and ExUnit

`Mix` is also used to run tests, and Elixir includes the testing framework `ExUnit`. So far, it has everything I want from testing framework - assertions, hooks, parallel or sequential tests, easy mocking. The mix tasks for running tests are also great, `mix test --failed` for instance is a wonderfully simple thing that just runs the tests that failed the previous run, and `mix test --seed <seed>` lets you run tests with a specified seeding so that randomized values are consistent.

I'll probably put it in a separate post, but our whole test suite (unit tests and integration-like tests) at work tests 4 separate microservices in just about 3 seconds. Combined with [mix test.watch](https://hexdocs.pm/mix_test_watch/readme.html), this means that I can have a separate shell running the tests continuously while writing code.

### Formatter

I don't have much to say here - I think every language should include a formatter, and just decide on a format. [Go](https://go.dev) does this exactly right, and with Elixir I get the same. I have it run when I save files and then check in CI that everything is formatted.

### Language Server

This is the one feature that the tooling isn't really up to other languages. Don't get me wrong, the language server does work and it gives you go to definition, squiggly lines etc, but it is a tad bit slow and more importantly, it quite often reports issues with dependencies on the top level (`mix.exs`). The only solution I've found is to clear the `.elixir_ls` directory and let it recompile.

It's worth mentioning that the language server is getting some love with an effort to bring it in as an [official](https://elixir-lang.org/blog/2024/08/15/welcome-elixir-language-server-team/) part of Elixir, but it's still in alpha and I've had some crashed with it so for now I'm sticking with [elixir-ls](https://github.com/elixir-lsp/elixir-ls).

### Standard Library & Documentation

The standard library is good. It has all the necessities, and is very well documented. I'm clumping documentation into this topic since it's a first class citizen of the language. [Doctest](https://hexdocs.pm/ex_unit/ExUnit.DocTest.html) is a fantastic tool for libraries to have up-to-date documentation examples.

## Ecosystem

The library ecosystem is both great and... not great. First of all, you can freely use Erlang libraries, meaning you have access to both a mature standard library and stable packages such as [brod](https://github.com/kafka4beam/brod).

The Elixir ecosystem has some very good and mature libraries such as [Phoenix](https://www.phoenixframework.org/), [Broadway](https://hexdocs.pm/broadway/introduction.html), [Ecto](https://hexdocs.pm/ecto/Ecto.html) and [Oban](https://hexdocs.pm/oban/Oban.html). Oban is so good I'm planning to write an appreciation post just for it.

At the same time, many libraries are pre-1.0. An example is [postgrex](https://hexdocs.pm/postgrex/readme.html), which is the default Postgres driver. It was initially published in 2014 and the current version is 0.22. Between 0.21 and 0.22 there was a breaking change (Elixir v1.15+ required). I think this fosters a culture where libraries aren't expected to reach a stable 1.0 stage, which increases developer churn and tech debt.

## The Language Itself

When I took the course in university for functional programming, I didn't really see the appeal. I was fostered with Java and OOP, and all of a sudden we're writing in an esoteric language that doesn't even have loops. We did pattern matching on lists, recursion and spawned processes from a supervisor we didn't understand. Needless to say, the course wasn't enough to actually understand Elixir (or BEAM).

Today, I can't imagine going back to the OOP world, and especially not JS/TS. I think I'm past the honeymoon phase now, and I still think the productivity and developer experience is phenomenal. The lack of loops isn't even an issue - just use the enumerable protocol. Pattern matching is a fantastic tool for error handling:

```elixir
# Log the error and just pass it along
def pass_on_error() do
  case bar() do
    {:ok, baz} -> baz
    {:error, error} -> 
      Logger.error(%{message: "Some error", error: error})
      {:error, error}
  end
end

# Assign baz to either the successful value, or nil
def swallow_error() do
  baz = case bar() do
    {:ok, baz} -> baz
    _ -> nil
  end
end

# Will raise a MatchError in case the pattern doesn't match
def raise_error() do
  {:ok, baz} = bar()
end
```

You get a clear separation between errors as values that you can handle, and raised errors for unexpected errors that you can't handle. [Saša Jurić's talk](https://www.youtube.com/watch?v=JvBT4XBdoUE) is a great starter on how the language and the runtime behaves, and how the application can keep running at (almost) full speed even though it is repeatedly running into unexpected errors.